// for (var i = 1; i < 6; i++) {
//   (function (j) {
//     setTimeout(function () {
//       console.log(j);
//     }, 1000 * j);
//   })(i);
// }

/**
 * Ο παραπάνω κώδικας χρησιμοποιεί μια άμεσα εκτελούμενη συνάρτηση (Immediately Invoked Function Expression - IIFE) για να δημιουργήσει ένα νέο κλειστό περιβάλλον (closure) σε κάθε επανάληψη του βρόχου. Αυτός ο μηχανισμός επιτρέπει στη μεταβλητή j να "δέσει" την τρέχουσα τιμή του i στη στιγμή της εκτέλεσης, αντί να επηρεάζεται από τη μεταβολή της τιμής του i στον βρόχο.

Ας το αναλύσουμε βήμα προς βήμα:

Ο βρόχος for:

Ο βρόχος εκτελείται από το i = 1 έως i < 6 (δηλαδή για τις τιμές 1, 2, 3, 4, 5).
Σε κάθε επανάληψη, καλείται η άμεσα εκτελούμενη συνάρτηση (function(j) { ... })(i).
Η IIFE:

Η άμεσα εκτελούμενη συνάρτηση (function(j) { ... })(i) δέχεται ως όρισμα την τρέχουσα τιμή του i.
Δημιουργεί ένα νέο κλειστό περιβάλλον (closure), όπου η τιμή του j αποθηκεύεται ξεχωριστά για την τρέχουσα επανάληψη.
Η setTimeout:

Μέσα στην IIFE, η setTimeout προγραμματίζει την εκτέλεση της ανώνυμης συνάρτησης function () { console.log(j); } μετά από 1000 * j milliseconds.
Σημαντικό είναι ότι η τιμή του j μέσα στη setTimeout είναι αυτή που είχε δεσμευτεί κατά τη δημιουργία του closure, δηλαδή η τιμή του i τη στιγμή της επανάληψης.
Γιατί αυξάνεται το j σωστά:

Σε κάθε επανάληψη του βρόχου, δημιουργείται νέο closure με διαφορετική τιμή για το j. Έτσι, όταν η setTimeout εκτελεί τη συνάρτηση, το j έχει τη σωστή τιμή.
Χωρίς την IIFE, αν χρησιμοποιούσαμε απευθείας το i μέσα στη setTimeout, η τιμή του i θα είχε αλλάξει μέχρι την εκτέλεση του setTimeout (δηλαδή, όταν ο βρόχος έχει τελειώσει, το i θα ήταν 6 για όλες τις καθυστερημένες εκτελέσεις). Η χρήση της IIFE διασφαλίζει ότι κάθε setTimeout "θυμάται" τη σωστή τιμή της επανάληψης.
 */

for (let i = 1; i < 6; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}
